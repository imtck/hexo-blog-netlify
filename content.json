{"meta":{"title":"我的小屋","subtitle":"","description":"","author":"imtck","url":"https://imtck.netlify.app","root":"/"},"pages":[{"title":"about","date":"2020-05-27T17:09:56.000Z","updated":"2020-05-27T17:11:29.780Z","comments":true,"path":"about/index.html","permalink":"https://imtck.netlify.app/about/index.html","excerpt":"","text":"一个小菜鸡"},{"title":"categories","date":"2020-05-27T13:27:22.000Z","updated":"2020-05-27T13:28:53.742Z","comments":true,"path":"categories/index.html","permalink":"https://imtck.netlify.app/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-27T13:18:17.000Z","updated":"2020-05-27T13:29:11.241Z","comments":true,"path":"tags/index.html","permalink":"https://imtck.netlify.app/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript-this的指向问题","slug":"JavaScript-This","date":"2020-05-27T12:35:47.000Z","updated":"2020-05-27T16:56:54.216Z","comments":true,"path":"2020/JavaScript-This/","link":"","permalink":"https://imtck.netlify.app/2020/JavaScript-This/","excerpt":"平时码代码的过程中总是会接触到this的问题，有的时候this可以调用，有的时候调用就是undefined，为了搞懂this指向相关的问题，以便在工作中节省效率，所以花了点时间去学习一下this的指向问题。","text":"平时码代码的过程中总是会接触到this的问题，有的时候this可以调用，有的时候调用就是undefined，为了搞懂this指向相关的问题，以便在工作中节省效率，所以花了点时间去学习一下this的指向问题。 普通函数调用this指向全局，即window对象。 var定义的是全局变量，所以this可以调用，因为this的指向是全局。在nodeJS环境下会出现undefined的返回值。 const和let定义的是局部变量，this的指向是全局，所以无法成功调用，返回undefined。const nameA = 'nameA'let nameB = 'nameB'var nameC = 'nameC'function Test() &#123; console.log(this.nameA); // undefined console.log(this.nameB); // undefined console.log(this.nameC); // \"nameC\"&#125;Test() 对象函数调用哪个函数调用，this指向哪里。Obj.Log()调用Log函数的时候，this指向的是Obj。 在Obj对象中，Obj的原型链下没有NumWin这个属性，所以this指向的NumWin返回值为undefined NumObj在Obj这个对象中有定义，所以this指向可以成功调用 打印window.NumWin的时候，因为在开始有定义过，没有指定const或者let，所以window.NumWin是全局变量，可以成功调用 打印this.window.NumWin的时候，因为this下面没有window这个属性，所以this.window会返回undefined，当在undefined后面继续调用的时候，因为没有形成原型链，所以浏览器会报错window.NumWin = 1const Obj = &#123; NumObj: 2, Log: function () &#123; console.log(this.NumWin) // undefined console.log(this.NumObj) // 2 console.log(window.NumWin) // 1 console.log(this.window.NumWin) // \"TypeError: Cannot read property 'NumWin' of undefined &#125;&#125;Obj.Log() 对象函数调用(使用内部函数)对象函数调用的时候，当函数体内没有定义变量的时候，this的指向是全局，这是可行的。但是如果函数体内有定义变量，此时我们希望this指向是函数体内的变量。如果调用的函数里面有内部函数，那么就会出现this指向不符合预期的情况，我们希望内部函数的this指向函数调用自身，但是this的指向确是全局。根据《js语言精粹》所说，这是设计上的一个错误，内部函数的this绑定了错误的对象，所以不能共享访问权。 定义一个全局变量Num，再定义一个函数体内的局部变量ObjNum 在函数体内建立一个内部函数，在该函数的体内再建立一个函数，并直接在该函数体内调用该函数 全局调用Obj内的ObjFn函数var Num = 5const Obj = &#123; ObjNum: 1, ObjFn: function () &#123; // var _this = this ObjAdd = function () &#123; // _this.ObjNum = Add(_this.ObjNum, _this.ObjNum) this.ObjNum = Add(this.ObjNum, this.ObjNum) this.Num = Add(this.Num, this.Num) &#125;; ObjAdd() &#125;&#125;;function Add(a, b) &#123; return a + b&#125;Obj.ObjFn() 分别打印上面JavaScript的属性值。 Num是全局变量，所以this指向是全局，不会影响调用 我们期望Obj.ObjNum的this指向是局部，但是this的指向是全局，所以不会对Obj.ObjNum的值产生影响console.log(Num)// 10console.log(Obj.ObjNum)// 1 解决上面this指向的问题可以通过建立一个变量，使这个建立的变量的this指向内部函数自身，这样就可以通过建立的变量来调用内部函数的变量,并对内部函数的变量进行修改。 如一开始的函数，如果使用注释的代码所使用的方法，并不会改变this本身的指向，本身还是指向全局，但是通过变量的this则是指向函数自身，这样就可以依据业务选择使用全局this还是局部的thisconsole.log(Num)// 10console.log(Obj.ObjNum)// 2 构造函数调用使用构造函数是，new会创建一个新的对象，新的对象会继承构造函数的属性和方法。不仅创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到这个创建的新对象。 打印MyFn,可以看出创建了一个包含了value的新对象，同时创建的get_value也被绑定在这个新的对象上 打印Fn，可以看出new的对象不会对原函数有任何的影响 打印MyFn.value，因为this绑定到了创建的MyFn对象上，所以可以成功获取数据 打印Fn.value，因为this绑定到了创建的MyFn对象上，没有对Fn这个本身的函数有影响，所以Fn的原型链上不包含value属性，所以会返回undefined 打印MyFn.get_value()，因为get_value()方法通过this绑定到了MyFn上，所以在函数调用函数，可以成功return之前绑定的this.value的值 打印Fn.get_value()，因为Fn上没有get_value()函数，所以浏览器会报错// 定义一个函数const Fn = function (string) &#123; this.value = string&#125;// 创建一个原型链Fn.prototype.get_value = function () &#123; return this.value&#125;let MyFn = new Fn('这是构造函数new的值')console.log(MyFn)// [object Object] &#123;// get_value: function () &#123;// return this.value// &#125;,// value: \"这是构造函数new的值\"// &#125;console.log(Fn)// function (string) &#123;// this.value = string// &#125;console.log(MyFn.value)// \"这是构造函数new的值\"console.log(Fn.value)// undefinedconsole.log(MyFn.get_value())// \"这是构造函数new的值\"console.log(Fn.get_value())// TypeError: Fn.get_value is not a function apply和call调用apply和call的作用一样，区别在于参数的传递apply和call的第一个参数都是函数体内this的指向qpply的第二个参数是一个集合对象call的第二个参数是是依次传入的参数 改变this指向 方法借用const ObjOne = &#123; Num: 1, Str: '对象1', ObjOneFn: function () &#123; console.log(this.Num) console.log(this.Str) // 2 // 对象2 // 3 // 对象3 &#125;&#125;const ObjTwo = &#123; Num: 2, Str: '对象2',&#125;const ObjThree = &#123; Num: 3, Str: '对象3'&#125;ObjOne.ObjOneFn.apply(ObjTwo)ObjOne.ObjOneFn.call(ObjThree) 箭头函数调用参考使用了内部函数的对象函数调用this，可以知道this的指向是全局，所以在这个函数中，打印的内容是undefined。 使用原本的函数const Obj = &#123; ObjNum: 1, ObjFn: function () &#123; ObjLog = function () &#123; console.log(this.ObjNum) // undefined &#125; ObjLog() &#125;&#125;Obj.ObjFn() 但是除了通过在函数体内定义一个变量，指定this，以实现内部函数调用函数体内变量的方法，还可以通过箭头函数直接改变this指向。因为箭头函数自身没有指定this的指向，所以会向上层作用域查找，ObjFn的this指向Obj，所以箭头函数的this也指向Obj，即可输出函数体内的数据。 使用箭头函数const Obj = &#123; ObjNum: 1, ObjFn: function () &#123; ObjLog = () =&gt; &#123; console.log(this.ObjNum) // 1 &#125; ObjLog() &#125;&#125;Obj.ObjFn()","categories":[{"name":"JS面试","slug":"JS面试","permalink":"https://imtck.netlify.app/categories/JS%E9%9D%A2%E8%AF%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/tags/JavaScript/"},{"name":"经验总结","slug":"经验总结","permalink":"https://imtck.netlify.app/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}]},{"title":"JavaScript-数组去重","slug":"JavaScript-数组去重","date":"2020-05-26T12:03:36.000Z","updated":"2020-05-27T16:57:02.729Z","comments":true,"path":"2020/JavaScript-数组去重/","link":"","permalink":"https://imtck.netlify.app/2020/JavaScript-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"在JavaScript操作中，经常有关于Array的操作，常见的操作有增删改查，排序去重等等，但是数组的去重经常要用到自己手写的代码，网上查询关于JavaScript的数组去重操作都有很多方法，但是关于数组的操作不是copy代码就可以做到高枕无忧的。","text":"在JavaScript操作中，经常有关于Array的操作，常见的操作有增删改查，排序去重等等，但是数组的去重经常要用到自己手写的代码，网上查询关于JavaScript的数组去重操作都有很多方法，但是关于数组的操作不是copy代码就可以做到高枕无忧的。 不同的方法会有不同的耗时，对于性能的影响也各不相同，在数据量小的时候尚不明显，但是在大数据的情况下，如果数据量很是庞大，那么耗时是很明显的，所以这么多关于数组去重的方法，到底那种方法更好呢。为了知道数组去重对于时间的消耗，手动进行了测试。 去重方法 10000 100000 1000000 10000000 利用ES6 Set去重 5ms 15ms 252ms 4148ms for循环，splice去重 273ms 27422ms 未测试 未测试 利用indexOf去重 138ms 13487ms 未测试 未测试 利用sort() 5ms 47ms 375ms 4018ms 利用includes 150ms 15134ms 未测试 未测试 利用Map结构数据 8ms 36ms 471ms 5873ms 创建数组 const ArrStart = new Date().getTime()const arr = []Array.from(new Array(100000), (item, index) =&gt; &#123; arr.push(index) arr.push(index + index) sasdsa&#125;)const ArrEnd = new Date().getTime()console.log('创建数据耗时：' + (ArrEnd - ArrStart) + 'ms') 去重方法 const Start = new Date().getTime()function Deduplication(arr) &#123; // 去重的具体方法&#125;Deduplication(arr)const End = new Date().getTime()console.log('去重耗时：' + (End - Start) + 'ms') 排序方法 const StartSort = new Date().getTime()const sortResult = arr.sort((a, b) =&gt; &#123; return a - b&#125;)const EndSort = new Date().getTime()console.log('排序耗时：' + (EndSort - StartSort) + 'ms') 利用ES6 Set去重(ES6常见)function Deduplication(arr) &#123; return Array.from(new Set(arr))&#125; 利用for嵌套for，然后splice去重(ES5常见)function Deduplication(arr) &#123; for(var i=0; i&lt;arr.length; i++)&#123; for(var j=i+1; j&lt;arr.length; j++)&#123; if(arr[i]==arr[j])&#123; //第一个等同于第二个，splice方法删除第二个 arr.splice(j,1); j--; &#125; &#125; &#125; return arr;&#125; 利用IndexOffunction Deduplication(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; var array = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (array.indexOf(arr[i]) === -1) &#123; array.push(arr[i]) &#125; &#125; return array;&#125; 利用sort()function Deduplication(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return; &#125; arr = arr.sort() var arrry = [arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== arr[i - 1]) &#123; arrry.push(arr[i]); &#125; &#125; return arrry;&#125; 利用includesfunction Deduplication(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; var array = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (!array.includes(arr[i])) &#123;//includes 检测数组是否有某个值 array.push(arr[i]); &#125; &#125; return array&#125; 利用Map结构数据function Deduplication(arr) &#123; let map = new Map(); let array = new Array(); // 数组用于返回结果 for (let i = 0; i &lt; arr.length; i++) &#123; if (map.has(arr[i])) &#123; // 如果有该key值 map.set(arr[i], true); &#125; else &#123; map.set(arr[i], false); // 如果没有该key值 array.push(arr[i]); &#125; &#125; return array;&#125; 经过一轮测试 利用ES6 Set去重 利用sort() 利用Map结构数据均可在百万数据量的时候实现快速去重，千万级数据也能较快去重","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/tags/JavaScript/"}]},{"title":"JavaScript的数组操作","slug":"JavaScript-Array","date":"2020-05-26T08:23:41.000Z","updated":"2020-05-27T16:56:57.946Z","comments":true,"path":"2020/JavaScript-Array/","link":"","permalink":"https://imtck.netlify.app/2020/JavaScript-Array/","excerpt":"平时会有许多关于数组的操作，所以看了下文档整理了下与数组有关的操作。","text":"平时会有许多关于数组的操作，所以看了下文档整理了下与数组有关的操作。 数组操作方法 数组操作结果 Array.length 查看数组长度 Array.from() 浅拷贝数组实例 Array.isArray() 确认是否为数组 Array.of() 创建新数组实例 Array.prototype.concat() 连接多个数组 Array.prototype.copyWithin() 浅复制数组 Array.prototype.filter() 过滤数组 Array.prototype.find() 查找数组 Array.prototype.forEach() 遍历数组 Array.prototype.includes() 查看数组是否包含内容 array.prototype.indexOf() 查找某个元素的索引 array.prototype.join() 组合数组元素返回字符串 array.prototype.push() 向数组末尾插入元素 array.prototype.pop() 删除数组末尾的元素 array.prototype.unshift() 向数组首位插入元素 array.prototype.shift() 删除数组首位的元素 array.prototype.reverse() 颠倒数组 array.prototype.sort() 数组排序 Array.length 查看数组的长度 const arr = ['a','b','c','d','e']console.log(arr.length)// 5 Array.from() 浅拷贝数组或可迭代对象 const array = ['a','b','c','d','e']const str = 'this'console.log(Array.from(array))// [\"a\", \"b\", \"c\", \"d\", \"e\"]console.log(Array.from(str))// [\"t\", \"h\", \"i\", \"s\"] Array.isArray() 确认是否为数组 const arr = ['a','b','c','d','e']console.log(Array.isArray(arr))// true Array.of() 创建具有可变数量参数的新数组实例 console.log(Array.of(5))// [5]console.log(Array(5))// [undefined, undefined, undefined, undefined, undefined] Array.prototype.concat() 连接多个数组 const arr1 = ['a1','b1','c1']const arr2 = ['a2','b2','c2']console.log(arr1.concat(arr2))// [\"a1\", \"b1\", \"c1\", \"a2\", \"b2\", \"c2\"]console.log(arr2.concat(arr1))// [\"a2\", \"b2\", \"c2\", \"a1\", \"b1\", \"c1\"] Array.prototype.copyWithin() 浅复制数组 详细用法 const arr = ['a','b','c','d','e']console.log(arr)// [\"a\", \"b\", \"c\", \"d\", \"e\"]arr.copyWithin(2,1,3)console.log(arr)// [\"a\", \"b\", \"b\", \"c\", \"e\"] Array.prototype.filter() 过滤数组 const arr = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']const arr1 = []arr.filter((item) =&gt; &#123; if (item.length &gt; 5) &#123; arr1.push(item) &#125;&#125;)console.log(arr1)// [\"exuberant\", \"destruction\", \"present\"] Array.prototype.find() 查找数组 const arr = [ &#123;name:'libai', age: 20&#125;, &#123;name:'dufu', age: 24&#125;, &#123;name:'baijuyi', age: 12&#125;, &#123;name:'hanyu', age: 40&#125;]arr.find((item) =&gt; &#123; if (item.name === 'baijuyi')&#123; console.log(item.age) &#125;&#125;)// 12 Array.prototype.indexOf() 找出某个元素在数组中的索引 const arr = ['a','b','c','d','e']console.log(arr.indexOf('c'))// 2 Array.prototype.join() 组合数组元素返回字符串 const arr = ['a','b','c','d','e']console.log(arr.join())// \"a,b,c,d,e\" Array.prototype.push() 添加元素到数组的头部 const arr = ['a','b','c','d','e']arr.unshift('123')console.log(arr)// [\"123\", \"a\", \"b\", \"c\", \"d\", \"e\"] Array.prototype.push() 添加元素到数组的末尾 const arr = ['a','b','c','d','e']arr.push('123')console.log(arr)// [\"a\", \"b\", \"c\", \"d\", \"e\", \"123\"] Array.prototype.shift() 删除数组最前面（头部）的元素 const arr = ['a','b','c','d','e']arr.shift()console.log(arr)// [\"b\", \"c\", \"d\", \"e\"] Array.prototype.pop() 删除数组末尾的元素 const arr = ['a','b','c','d','e']arr.pop()console.log(arr)// [\"a\", \"b\", \"c\", \"d\"] Array.prototype.reverse() 颠倒数组的顺序 const arr = ['a','b','c','d','e']arr.reverse()console.log(arr)// [\"e\", \"d\", \"c\", \"b\", \"a\"] Array.prototype.sort() 数组排序 const arr = [1, 30, 9, 21, 100000, 564]console.log(arr.sort())// [1, 100000, 21, 30, 564, 9]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/tags/JavaScript/"}]}],"categories":[{"name":"JS面试","slug":"JS面试","permalink":"https://imtck.netlify.app/categories/JS%E9%9D%A2%E8%AF%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/tags/JavaScript/"},{"name":"经验总结","slug":"经验总结","permalink":"https://imtck.netlify.app/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}]}