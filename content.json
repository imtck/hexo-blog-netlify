{"meta":{"title":"我的小屋","subtitle":"","description":"","author":"imtck","url":"https://imtck.netlify.app","root":"/"},"pages":[{"title":"about","date":"2020-05-27T17:09:56.000Z","updated":"2020-05-27T17:11:29.780Z","comments":true,"path":"about/index.html","permalink":"https://imtck.netlify.app/about/index.html","excerpt":"","text":"一个小菜鸡 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-05-27T13:27:22.000Z","updated":"2020-05-27T13:28:53.742Z","comments":true,"path":"categories/index.html","permalink":"https://imtck.netlify.app/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-05-27T13:18:17.000Z","updated":"2020-05-27T13:29:11.241Z","comments":true,"path":"tags/index.html","permalink":"https://imtck.netlify.app/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"vip","date":"2020-05-29T10:47:21.000Z","updated":"2020-05-29T10:47:21.976Z","comments":true,"path":"vip/index.html","permalink":"https://imtck.netlify.app/vip/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"JavaScript-Array-几个数组函数的比较","slug":"JavaScript-Array-Compare","date":"2020-05-29T02:30:24.000Z","updated":"2020-05-29T05:54:29.036Z","comments":true,"path":"2020/JavaScript-Array-Compare/","link":"","permalink":"https://imtck.netlify.app/2020/JavaScript-Array-Compare/","excerpt":"因为平时forEach用的多，知其然不知其所以然。所以对几个数组函数，Array.map()，Array.forEach()，Array.reduce()的用法和使用场景做出了简单的分析","text":"因为平时forEach用的多，知其然不知其所以然。所以对几个数组函数，Array.map()，Array.forEach()，Array.reduce()的用法和使用场景做出了简单的分析 官方文档有过介绍，forEach和map都是遍历数据之后可以进行操作 forEach可以改变原数组，map不能改变原数组，map是通过生成新数组来实现操作的 但是实际测试不然，forEach是通过数组引用改变原数组，实际map也是可以这样做到的 Array.prototype.forEach() MDN官方文档 遍历数组的每一项，以执行给定函数，不可以返回新数组 在操作中写函数，但是不涉及对数组的操作，不会影响原数组const arr = [4, 5, 8]arr.forEach((item) =&gt; item * 2)console.log(arr) // [4, 5, 8] 在操作中写函数，涉及对数组引用方式的操作，会改变原数组const arr = [4, 5, 8]arr.forEach((item, index) =&gt; arr[index] = item * 2)console.log(arr) // [ 8, 10, 16 ] 尝试把forEach的遍历处理的数据写入新数组，返回undefined 由此得知forEach不能创建数组const arr = [4, 5, 8]let arr1 = arr.forEach((item) =&gt; item * 2)console.log(arr1) // undefined Array.prototype.map() MDN官方文档 在操作中写函数，但是不涉及对数组的操作，不会影响原数组const arr = [4, 5, 8]arr.map((item) =&gt; item * 2)console.log(arr) // [ 4, 5, 8 ] 在操作中写函数，涉及对数组引用的操作，会改变原数组const arr = [4, 5, 8]arr.map((item, index) =&gt; arr[index] = item * 2)console.log(arr) // [ 8, 10, 16 ] 尝试把map的遍历处理的数据写入新数组，返回对应数据 由此得知map可以创建新的栈区const arr = [4, 5, 8]let arr1 = arr.map((item) =&gt; item * 2)console.log(arr1) // [ 8, 10, 16 ] Array.prototype.reduce() MDN官方文档 如果对数据处理是需要循环处理，并且下一次的处理需要和上一次处理的数据相关联，而且处理流程的函数方法都一样，那么可以通过reduce，省略很多步骤 累加const arr = [4, 5, 8, 12, 23]const reducer = (a, b) =&gt; a + bconst test1 = arr.reduce(reducer)console.log(test1) 分析总结 map和forEach 虽然文档说map和forEach在对原数组操作模式上不一样 测试之后其实也是有共通之处的 所不同的地方在于，map可以返回一个新数组，forEach不可以 所以结合官方和众人的经验总结，对于map和forEach在不同场景下选取不同的使用 如果需要涉及对数据有改动的相关操作使用map 如果是对数据无改动，对数据查询，写入数据库等操作，使用forEach 与reduce的使用关系 当复杂的函数可以使用map处理 简单的函数处理，重复工作的累加累减这种可以使用reduce 使用reduce可以减少代码量 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/categories/JavaScript/"},{"name":"Array","slug":"JavaScript/Array","permalink":"https://imtck.netlify.app/categories/JavaScript/Array/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/tags/JavaScript/"}]},{"title":"JavaScript-Array","slug":"JavaScript-Array","date":"2020-05-28T16:36:53.000Z","updated":"2020-05-29T02:36:54.268Z","comments":true,"path":"2020/JavaScript-Array/","link":"","permalink":"https://imtck.netlify.app/2020/JavaScript-Array/","excerpt":"简单罗列了数组及数组操作的相关知识。","text":"简单罗列了数组及数组操作的相关知识。 创建数组 内存 堆区 手动开辟，手动释放 栈区 保存基本数据类型，函数结束自动释放 new 堆区开辟内存空间存储对象 返回堆区的对象引用 栈区引用，访问堆区的对象 构造函数创建 创建空数组 let arr = new Array() 创建确定容量的数组 let arr = new Array(5) 创建拥有数据的数组 let arr = new Array(1，'2', false) 字面量法创建数组 创建空数组 let arr = [] 创建拥有数据的数组 let arr = [1，'2', false] 访问数组 数组元素访问const arr = [1, 2, 3, 4, 5]console.log(arr[3]) // 4 取值const arr = [1, 2, 3, 4, 5]const val = arr[1]console.log(val) // 2 赋值const arr = [1, 2, 3, 4, 5]arr[3] = 6console.log(arr) // [1, 2, 3, 6, 5] 数组常用方法 操作 功能 参数 返回值 push(item1, item2, …) 在数组末尾添加一个或者多个数组 要添加的元素 添加数据后的数组 unshift(item1, item2, …) 在数组开头添加一个或者多个数组 要添加的元素 添加数据后的数组 pop() 删除数组末尾的一个元素 无 删除数据后的数组 shift() 删除数组开头的一个元素 无 删除数据后的数组 join(str) 将数组元素用字符串连接成一个新字符串 一个字符串 拼接的结果（不改变原数组） reverse() 倒置数组元素 无 倒置以后的数组（改变原数组） slice(startIndex, endIndex) 在数组中从开始下标截取到结束下标 开始和结束的下标 截取的数组 不改变原数组，不包含下标元素） splice(下标，个数，item1, …) 在数组中添加或删除元素 item是要已添加到数组的新元素 去除删除元素和加上新增的元素的数组 contact() 多个数组连接 无 连接后的数组 indexOf(item) 从左向右查询参数元素的索引 要查找的元素值 查找的元素索引，否则返回-1 lastIndexOf(item) 从右向左查询参数元素的索引 要查找的元素值 查找的元素索引，否则返回-1 数组遍历 快速遍历 for - inconst arr = ['一', '二', '三', '四', '五']for (const i in arr) { console.log(arr[i])} for 循环遍历const arr = ['一', '二', '三', '四', '五']for (let i = 0, len = arr.length; i &lt; len; i++) { console.log(arr[i])} forEach 循环遍历const arr = ['一', '二', '三', '四', '五']arr.forEach(item =&gt; { console.log(item)}) 数组排序 冒泡排序const arr = [4, 5, 8, 2, 6, 17]for (let i in arr) { // 冒泡排序的核心 for (let j = 0; j &lt; arr.length - i; j++) { // 决定冒泡排序的升降序 // arr[j] &gt; arr[j + 1] 升序 // arr[j] &lt; arr[j + 1] 降序 if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] } }}console.log(arr) sort() 无参数根据Unicode位点排序const arr = [4, 5, 8, 2, 6, 17]arr.sort()console.log(arr)// [ 17, 2, 4, 5, 6, 8 ]arr.sort((a, b) =&gt; a - b)console.log(arr)// [ 2, 4, 5, 6, 8, 17 ]arr.sort((a, b) =&gt; b - a)console.log(arr)// [ 17, 8, 6, 5, 4, 2 ] 迭代方法 5个迭代方法的运行函数接受三个参数，(item, index, array) erery() 如果数组元素都满足，则返回true，否则falseconst arr = [4, 5, 8, 2, 6, 17]const test1 = arr.every((item) =&gt; item &gt; 4)console.log(test1) // falseconst test2 = arr.every((item) =&gt; item &gt; 1)console.log(test2) // true some() 如果数组元素都不满足，则返回false，否则trueconst arr = [4, 5, 8, 2, 6, 17]const test1 = arr.some((item) =&gt; item &gt; 9)console.log(test1) // trueconst test2 = arr.some((item) =&gt; item &gt; 20)console.log(test2) // false filter() 如果数组元素都满足，则返回true项组成的数组const arr = [4, 5, 8, 2, 6, 17]const test1 = arr.filter((item) =&gt; item &gt; 4)console.log(test1) // [ 5, 8, 6, 17 ]const test2 = arr.filter((item) =&gt; item &gt; 6)console.log(test2) // [ 8, 17 ] forEach() 遍历数组的每一项，以执行给定函数const arr = [4, 5, 8, 2, 6, 17]arr.forEach((item) =&gt; console.log(item)) map() 遍历数组的每一项，以执行给定函数，可以返回新数组const arr = [4, 5, 8, 2, 6, 17]let arr1 = arr.map((item) =&gt; item * 2)console.log(arr1) 归并方法 2个归并方法，可以迭代数组所有项，构建最终返回的值 处理数组元素的时候，数组中两个元素经过处理返回值，会和下一个元素继续形成数据处理关系。直到数组中只有一个值 reduce() 从左到右处理const arr = [3, 6, 20]const reducer = (a, b) =&gt; a / bconst test1 = arr.reduce(reducer)console.log(test1) // 0.025 reduceRight() 从右到左处理const arr = [3, 6, 20]const reducer = (a, b) =&gt; a / bconst test2 = arr.reduceRight(reducer)console.log(test2) // 1.1111111111111112 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/categories/JavaScript/"},{"name":"Array","slug":"JavaScript/Array","permalink":"https://imtck.netlify.app/categories/JavaScript/Array/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/tags/JavaScript/"}]},{"title":"JavaScript-this的指向问题","slug":"JavaScript-This","date":"2020-05-27T12:35:47.000Z","updated":"2020-05-27T16:56:54.216Z","comments":true,"path":"2020/JavaScript-This/","link":"","permalink":"https://imtck.netlify.app/2020/JavaScript-This/","excerpt":"平时码代码的过程中总是会接触到this的问题，有的时候this可以调用，有的时候调用就是undefined，为了搞懂this指向相关的问题，以便在工作中节省效率，所以花了点时间去学习一下this的指向问题。","text":"平时码代码的过程中总是会接触到this的问题，有的时候this可以调用，有的时候调用就是undefined，为了搞懂this指向相关的问题，以便在工作中节省效率，所以花了点时间去学习一下this的指向问题。 普通函数调用 this指向全局，即window对象。 var定义的是全局变量，所以this可以调用，因为this的指向是全局。在nodeJS环境下会出现undefined的返回值。 const和let定义的是局部变量，this的指向是全局，所以无法成功调用，返回undefined。 const nameA = 'nameA'let nameB = 'nameB'var nameC = 'nameC'function Test() { console.log(this.nameA); // undefined console.log(this.nameB); // undefined console.log(this.nameC); // \"nameC\"}Test() 对象函数调用 哪个函数调用，this指向哪里。 Obj.Log()调用Log函数的时候，this指向的是Obj。 在Obj对象中，Obj的原型链下没有NumWin这个属性，所以this指向的NumWin返回值为undefined NumObj在Obj这个对象中有定义，所以this指向可以成功调用 打印window.NumWin的时候，因为在开始有定义过，没有指定const或者let，所以window.NumWin是全局变量，可以成功调用 打印this.window.NumWin的时候，因为this下面没有window这个属性，所以this.window会返回undefined，当在undefined后面继续调用的时候，因为没有形成原型链，所以浏览器会报错 window.NumWin = 1const Obj = { NumObj: 2, Log: function () { console.log(this.NumWin) // undefined console.log(this.NumObj) // 2 console.log(window.NumWin) // 1 console.log(this.window.NumWin) // \"TypeError: Cannot read property 'NumWin' of undefined }}Obj.Log() 对象函数调用(使用内部函数) 对象函数调用的时候，当函数体内没有定义变量的时候，this的指向是全局，这是可行的。但是如果函数体内有定义变量，此时我们希望this指向是函数体内的变量。 如果调用的函数里面有内部函数，那么就会出现this指向不符合预期的情况，我们希望内部函数的this指向函数调用自身，但是this的指向确是全局。 根据《js语言精粹》所说，这是设计上的一个错误，内部函数的this绑定了错误的对象，所以不能共享访问权。 定义一个全局变量Num，再定义一个函数体内的局部变量ObjNum 在函数体内建立一个内部函数，在该函数的体内再建立一个函数，并直接在该函数体内调用该函数 全局调用Obj内的ObjFn函数 var Num = 5const Obj = { ObjNum: 1, ObjFn: function () { // var _this = this ObjAdd = function () { // _this.ObjNum = Add(_this.ObjNum, _this.ObjNum) this.ObjNum = Add(this.ObjNum, this.ObjNum) this.Num = Add(this.Num, this.Num) }; ObjAdd() }};function Add(a, b) { return a + b}Obj.ObjFn() 分别打印上面JavaScript的属性值。 Num是全局变量，所以this指向是全局，不会影响调用 我们期望Obj.ObjNum的this指向是局部，但是this的指向是全局，所以不会对Obj.ObjNum的值产生影响 console.log(Num)// 10console.log(Obj.ObjNum)// 1 解决上面this指向的问题可以通过建立一个变量，使这个建立的变量的this指向内部函数自身，这样就可以通过建立的变量来调用内部函数的变量,并对内部函数的变量进行修改。 如一开始的函数，如果使用注释的代码所使用的方法，并不会改变this本身的指向，本身还是指向全局，但是通过变量的this则是指向函数自身，这样就可以依据业务选择使用全局this还是局部的this console.log(Num)// 10console.log(Obj.ObjNum)// 2 构造函数调用 使用构造函数是，new会创建一个新的对象，新的对象会继承构造函数的属性和方法。 不仅创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到这个创建的新对象。 打印MyFn,可以看出创建了一个包含了value的新对象，同时创建的get_value也被绑定在这个新的对象上 打印Fn，可以看出new的对象不会对原函数有任何的影响 打印MyFn.value，因为this绑定到了创建的MyFn对象上，所以可以成功获取数据 打印Fn.value，因为this绑定到了创建的MyFn对象上，没有对Fn这个本身的函数有影响，所以Fn的原型链上不包含value属性，所以会返回undefined 打印MyFn.get_value()，因为get_value()方法通过this绑定到了MyFn上，所以在函数调用函数，可以成功return之前绑定的this.value的值 打印Fn.get_value()，因为Fn上没有get_value()函数，所以浏览器会报错 // 定义一个函数const Fn = function (string) { this.value = string}// 创建一个原型链Fn.prototype.get_value = function () { return this.value}let MyFn = new Fn('这是构造函数new的值')console.log(MyFn)// [object Object] {// get_value: function () {// return this.value// },// value: \"这是构造函数new的值\"// }console.log(Fn)// function (string) {// this.value = string// }console.log(MyFn.value)// \"这是构造函数new的值\"console.log(Fn.value)// undefinedconsole.log(MyFn.get_value())// \"这是构造函数new的值\"console.log(Fn.get_value())// TypeError: Fn.get_value is not a function apply和call调用 apply和call的作用一样，区别在于参数的传递 apply和call的第一个参数都是函数体内this的指向 qpply的第二个参数是一个集合对象 call的第二个参数是是依次传入的参数 改变this指向 方法借用 const ObjOne = { Num: 1, Str: '对象1', ObjOneFn: function () { console.log(this.Num) console.log(this.Str) // 2 // 对象2 // 3 // 对象3 }}const ObjTwo = { Num: 2, Str: '对象2',}const ObjThree = { Num: 3, Str: '对象3'}ObjOne.ObjOneFn.apply(ObjTwo)ObjOne.ObjOneFn.call(ObjThree) 箭头函数调用 参考使用了内部函数的对象函数调用this，可以知道this的指向是全局，所以在这个函数中，打印的内容是undefined。 使用原本的函数 const Obj = { ObjNum: 1, ObjFn: function () { ObjLog = function () { console.log(this.ObjNum) // undefined } ObjLog() }}Obj.ObjFn() 但是除了通过在函数体内定义一个变量，指定this，以实现内部函数调用函数体内变量的方法，还可以通过箭头函数直接改变this指向。 因为箭头函数自身没有指定this的指向，所以会向上层作用域查找，ObjFn的this指向Obj，所以箭头函数的this也指向Obj，即可输出函数体内的数据。 使用箭头函数 const Obj = { ObjNum: 1, ObjFn: function () { ObjLog = () =&gt; { console.log(this.ObjNum) // 1 } ObjLog() }}Obj.ObjFn() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JS面试","slug":"JS面试","permalink":"https://imtck.netlify.app/categories/JS%E9%9D%A2%E8%AF%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/tags/JavaScript/"},{"name":"经验总结","slug":"经验总结","permalink":"https://imtck.netlify.app/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}]},{"title":"JavaScript-数组去重","slug":"JavaScript-数组去重","date":"2020-05-26T12:03:36.000Z","updated":"2020-05-29T02:29:15.600Z","comments":true,"path":"2020/JavaScript-数组去重/","link":"","permalink":"https://imtck.netlify.app/2020/JavaScript-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"在JavaScript操作中，经常有关于Array的操作，常见的操作有增删改查，排序去重等等，但是数组的去重经常要用到自己手写的代码，网上查询关于JavaScript的数组去重操作都有很多方法，但是关于数组的操作不是copy代码就可以做到高枕无忧的。","text":"在JavaScript操作中，经常有关于Array的操作，常见的操作有增删改查，排序去重等等，但是数组的去重经常要用到自己手写的代码，网上查询关于JavaScript的数组去重操作都有很多方法，但是关于数组的操作不是copy代码就可以做到高枕无忧的。 不同的方法会有不同的耗时，对于性能的影响也各不相同，在数据量小的时候尚不明显，但是在大数据的情况下，如果数据量很是庞大，那么耗时是很明显的，所以这么多关于数组去重的方法，到底那种方法更好呢。 为了知道数组去重对于时间的消耗，手动进行了测试。 去重方法 10000 100000 1000000 10000000 利用ES6 Set去重 5ms 15ms 252ms 4148ms for循环，splice去重 273ms 27422ms 未测试 未测试 利用indexOf去重 138ms 13487ms 未测试 未测试 利用sort() 5ms 47ms 375ms 4018ms 利用includes 150ms 15134ms 未测试 未测试 利用Map结构数据 8ms 36ms 471ms 5873ms 创建数组 const ArrStart = new Date().getTime()const arr = []Array.from(new Array(100000), (item, index) =&gt; { arr.push(index) arr.push(index + index) sasdsa})const ArrEnd = new Date().getTime()console.log('创建数据耗时：' + (ArrEnd - ArrStart) + 'ms') 去重方法 const Start = new Date().getTime()function Deduplication(arr) { // 去重的具体方法}Deduplication(arr)const End = new Date().getTime()console.log('去重耗时：' + (End - Start) + 'ms') 排序方法 const StartSort = new Date().getTime()const sortResult = arr.sort((a, b) =&gt; { return a - b})const EndSort = new Date().getTime()console.log('排序耗时：' + (EndSort - StartSort) + 'ms') 利用ES6 Set去重(ES6常见) function Deduplication(arr) { return Array.from(new Set(arr))} 利用for嵌套for，然后splice去重(ES5常见) function Deduplication(arr) { for(var i=0; i&lt;arr.length; i++){ for(var j=i+1; j&lt;arr.length; j++){ if(arr[i]==arr[j]){ //第一个等同于第二个，splice方法删除第二个 arr.splice(j,1); j--; } } } return arr;} 利用IndexOf function Deduplication(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var array = []; for (var i = 0; i &lt; arr.length; i++) { if (array.indexOf(arr[i]) === -1) { array.push(arr[i]) } } return array;} 利用sort() function Deduplication(arr) { if (!Array.isArray(arr)) { console.log('type error!') return; } arr = arr.sort() var arrry = [arr[0]]; for (var i = 1; i &lt; arr.length; i++) { if (arr[i] !== arr[i - 1]) { arrry.push(arr[i]); } } return arrry;} 利用includes function Deduplication(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var array = []; for (var i = 0; i &lt; arr.length; i++) { if (!array.includes(arr[i])) {//includes 检测数组是否有某个值 array.push(arr[i]); } } return array} 利用Map结构数据 function Deduplication(arr) { let map = new Map(); let array = new Array(); // 数组用于返回结果 for (let i = 0; i &lt; arr.length; i++) { if (map.has(arr[i])) { // 如果有该key值 map.set(arr[i], true); } else { map.set(arr[i], false); // 如果没有该key值 array.push(arr[i]); } } return array;} 经过一轮测试 利用ES6 Set去重 利用sort() 利用Map结构数据 均可在百万数据量的时候实现快速去重，千万级数据也能较快去重 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/categories/JavaScript/"},{"name":"Array","slug":"JavaScript/Array","permalink":"https://imtck.netlify.app/categories/JavaScript/Array/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/tags/JavaScript/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/categories/JavaScript/"},{"name":"Array","slug":"JavaScript/Array","permalink":"https://imtck.netlify.app/categories/JavaScript/Array/"},{"name":"JS面试","slug":"JS面试","permalink":"https://imtck.netlify.app/categories/JS%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://imtck.netlify.app/tags/JavaScript/"},{"name":"经验总结","slug":"经验总结","permalink":"https://imtck.netlify.app/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}]}