<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript-Array</title>
    <url>/2020/JavaScript-Array/</url>
    <content><![CDATA[<p>简单罗列了数组及数组操作的相关知识。</p>
<a id="more"></a>
<h4 id="创建数组">创建数组</h4>
<ul>
<li>内存
<ul>
<li>堆区 手动开辟，手动释放</li>
<li>栈区 保存基本数据类型，函数结束自动释放</li>
</ul>
</li>
<li>new
<ul>
<li>堆区开辟内存空间存储对象</li>
<li>返回堆区的对象引用</li>
<li>栈区引用，访问堆区的对象</li>
</ul>
</li>
<li>构造函数创建
<ul>
<li>创建空数组 <code>let arr = new Array()</code></li>
<li>创建确定容量的数组 <code>let arr = new Array(5)</code></li>
<li>创建拥有数据的数组 <code>let arr = new Array(1，'2', false)</code></li>
</ul>
</li>
<li>字面量法创建数组
<ul>
<li>创建空数组 <code>let arr = []</code></li>
<li>创建拥有数据的数组 <code>let arr = [1，'2', false]</code></li>
</ul>
</li>
</ul>
<h4 id="访问数组">访问数组</h4>
<ul>
<li>数组元素访问<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3</span>]) <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>取值<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> val = arr[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(val) <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>赋值<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 6, 5]</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="数组常用方法">数组常用方法</h4>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
<th>参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>push(item1, item2, …)</td>
<td>在数组末尾添加一个或者多个数组</td>
<td>要添加的元素</td>
<td>添加数据后的数组</td>
</tr>
<tr>
<td>unshift(item1, item2, …)</td>
<td>在数组开头添加一个或者多个数组</td>
<td>要添加的元素</td>
<td>添加数据后的数组</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组末尾的一个元素</td>
<td>无</td>
<td>删除数据后的数组</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组开头的一个元素</td>
<td>无</td>
<td>删除数据后的数组</td>
</tr>
<tr>
<td>join(str)</td>
<td>将数组元素用字符串连接成一个新字符串</td>
<td>一个字符串</td>
<td>拼接的结果（不改变原数组）</td>
</tr>
<tr>
<td>reverse()</td>
<td>倒置数组元素</td>
<td>无</td>
<td>倒置以后的数组（改变原数组）</td>
</tr>
<tr>
<td>slice(startIndex, endIndex)</td>
<td>在数组中从开始下标截取到结束下标</td>
<td>开始和结束的下标</td>
<td>截取的数组 不改变原数组，不包含下标元素）</td>
</tr>
<tr>
<td>splice(下标，个数，item1, …)</td>
<td>在数组中添加或删除元素</td>
<td>item是要已添加到数组的新元素</td>
<td>去除删除元素和加上新增的元素的数组</td>
</tr>
<tr>
<td>contact()</td>
<td>多个数组连接</td>
<td>无</td>
<td>连接后的数组</td>
</tr>
<tr>
<td>indexOf(item)</td>
<td>从左向右查询参数元素的索引</td>
<td>要查找的元素值</td>
<td>查找的元素索引，否则返回-1</td>
</tr>
<tr>
<td>lastIndexOf(item)</td>
<td>从右向左查询参数元素的索引</td>
<td>要查找的元素值</td>
<td>查找的元素索引，否则返回-1</td>
</tr>
</tbody>
</table>
<h4 id="数组遍历">数组遍历</h4>
<ul>
<li>快速遍历 <code>for - in</code><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'一'</span>, <span class="string">'二'</span>, <span class="string">'三'</span>, <span class="string">'四'</span>, <span class="string">'五'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> arr) {</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>for 循环遍历<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'一'</span>, <span class="string">'二'</span>, <span class="string">'三'</span>, <span class="string">'四'</span>, <span class="string">'五'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) {</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>forEach 循环遍历<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'一'</span>, <span class="string">'二'</span>, <span class="string">'三'</span>, <span class="string">'四'</span>, <span class="string">'五'</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="数组排序">数组排序</h4>
<ul>
<li>冒泡排序<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">17</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) {</span><br><span class="line">  <span class="comment">// 冒泡排序的核心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) {</span><br><span class="line">    <span class="comment">// 决定冒泡排序的升降序</span></span><br><span class="line">    <span class="comment">// arr[j] &gt; arr[j + 1] 升序</span></span><br><span class="line">    <span class="comment">// arr[j] &lt; arr[j + 1] 降序</span></span><br><span class="line">    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) {</span><br><span class="line">      [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]]</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>sort() 无参数根据Unicode位点排序<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">17</span>]</span><br><span class="line">arr.sort()</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">// [ 17, 2, 4, 5, 6, 8 ]</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">// [ 2, 4, 5, 6, 8, 17 ]</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">// [ 17, 8, 6, 5, 4, 2 ]</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="迭代方法">迭代方法</h4>
<p>5个迭代方法的运行函数接受三个参数，(item, index, array)</p>
<ul>
<li>erery() 如果数组元素都满足，则返回true，否则false<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">17</span>]</span><br><span class="line"><span class="keyword">const</span> test1 = arr.every(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test1) <span class="comment">// false</span></span><br><span class="line"><span class="keyword">const</span> test2 = arr.every(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test2) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>some() 如果数组元素都不满足，则返回false，否则true<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">17</span>]</span><br><span class="line"><span class="keyword">const</span> test1 = arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">9</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test1) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> test2 = arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test2) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>filter() 如果数组元素都满足，则返回true项组成的数组<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">17</span>]</span><br><span class="line"><span class="keyword">const</span> test1 = arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test1) <span class="comment">// [ 5, 8, 6, 17 ]</span></span><br><span class="line"><span class="keyword">const</span> test2 = arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test2) <span class="comment">// [ 8, 17 ]</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>forEach() 遍历数组的每一项，以执行给定函数<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">17</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item))</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>map() 遍历数组的每一项，以执行给定函数，可以返回新数组<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">17</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="归并方法">归并方法</h4>
<p>2个归并方法，可以迭代数组所有项，构建最终返回的值<br>
处理数组元素的时候，数组中两个元素经过处理返回值，会和下一个元素继续形成数据处理关系。直到数组中只有一个值</p>
<ul>
<li>reduce() 从左到右处理<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a / b</span><br><span class="line"><span class="keyword">const</span> test1 = arr.reduce(reducer)</span><br><span class="line"><span class="built_in">console</span>.log(test1) <span class="comment">// 0.025</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>reduceRight() 从右到左处理<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a / b</span><br><span class="line"><span class="keyword">const</span> test2 = arr.reduceRight(reducer)</span><br><span class="line"><span class="built_in">console</span>.log(test2) <span class="comment">// 1.1111111111111112</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-this的指向问题</title>
    <url>/2020/JavaScript-This/</url>
    <content><![CDATA[<p>平时码代码的过程中总是会接触到this的问题，有的时候this可以调用，有的时候调用就是<code>undefined</code>，为了搞懂this指向相关的问题，以便在工作中节省效率，所以花了点时间去学习一下this的指向问题。</p>
<a id="more"></a>
<h3 id="普通函数调用">普通函数调用</h3>
<p>this指向全局，即<code>window</code>对象。</p>
<ul>
<li><code>var</code>定义的是全局变量，所以this可以调用，因为this的指向是全局。在<code>nodeJS</code>环境下会出现<code>undefined</code>的返回值。</li>
<li><code>const</code>和<code>let</code>定义的是局部变量，this的指向是全局，所以无法成功调用，返回<code>undefined</code>。</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameA = <span class="string">'nameA'</span></span><br><span class="line"><span class="keyword">let</span> nameB = <span class="string">'nameB'</span></span><br><span class="line"><span class="keyword">var</span> nameC = <span class="string">'nameC'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.nameA);</span><br><span class="line">  <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.nameB);</span><br><span class="line">  <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.nameC);</span><br><span class="line">  <span class="comment">// "nameC"</span></span><br><span class="line">}</span><br><span class="line">Test()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="对象函数调用">对象函数调用</h3>
<p>哪个函数调用，this指向哪里。<br>
<code>Obj.Log()</code>调用<code>Log</code>函数的时候，this指向的是<code>Obj</code>。</p>
<ul>
<li>在<code>Obj</code>对象中，<code>Obj</code>的原型链下没有<code>NumWin</code>这个属性，所以this指向的<code>NumWin</code>返回值为<code>undefined</code></li>
<li><code>NumObj</code>在<code>Obj</code>这个对象中有定义，所以this指向可以成功调用</li>
<li>打印<code>window.NumWin</code>的时候，因为在开始有定义过，没有指定<code>const</code>或者<code>let</code>，所以<code>window.NumWin</code>是全局变量，可以成功调用</li>
<li>打印<code>this.window.NumWin</code>的时候，因为this下面没有<code>window</code>这个属性，所以<code>this.window</code>会返回<code>undefined</code>，当在<code>undefined</code>后面继续调用的时候，因为没有形成原型链，所以浏览器会报错</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.NumWin = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> Obj = {</span><br><span class="line">  NumObj: <span class="number">2</span>,</span><br><span class="line">  Log: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.NumWin)</span><br><span class="line">    <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.NumObj)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.NumWin)</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.window.NumWin)</span><br><span class="line">    <span class="comment">// "TypeError: Cannot read property 'NumWin' of undefined</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">Obj.Log()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="对象函数调用-使用内部函数">对象函数调用(使用内部函数)</h3>
<p>对象函数调用的时候，当函数体内没有定义变量的时候，this的指向是全局，这是可行的。但是如果函数体内有定义变量，此时我们希望this指向是函数体内的变量。<br>
如果调用的函数里面有内部函数，那么就会出现this指向不符合预期的情况，我们希望内部函数的this指向函数调用自身，但是this的指向确是全局。<br>
根据《js语言精粹》所说，这是设计上的一个错误，内部函数的this绑定了错误的对象，所以不能共享访问权。</p>
<ul>
<li>定义一个全局变量<code>Num</code>，再定义一个函数体内的局部变量<code>ObjNum</code></li>
<li>在函数体内建立一个内部函数，在该函数的体内再建立一个函数，并直接在该函数体内调用该函数</li>
<li>全局调用<code>Obj</code>内的<code>ObjFn</code>函数</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Num = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> Obj = {</span><br><span class="line">  ObjNum: <span class="number">1</span>,</span><br><span class="line">  ObjFn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// var _this = this</span></span><br><span class="line">    ObjAdd = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      <span class="comment">// _this.ObjNum = Add(_this.ObjNum, _this.ObjNum)</span></span><br><span class="line">      <span class="keyword">this</span>.ObjNum = Add(<span class="keyword">this</span>.ObjNum, <span class="keyword">this</span>.ObjNum)</span><br><span class="line">      <span class="keyword">this</span>.Num = Add(<span class="keyword">this</span>.Num, <span class="keyword">this</span>.Num)</span><br><span class="line">    };</span><br><span class="line">    ObjAdd()</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params">a, b</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br><span class="line">Obj.ObjFn()</span><br></pre></td></tr></tbody></table></figure>
<p>分别打印上面JavaScript的属性值。</p>
<ul>
<li>Num是全局变量，所以this指向是全局，不会影响调用</li>
<li>我们期望Obj.ObjNum的this指向是局部，但是this的指向是全局，所以不会对Obj.ObjNum的值产生影响</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Num)</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(Obj.ObjNum)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>
<p>解决上面this指向的问题可以通过建立一个变量，使这个建立的变量的this指向内部函数自身，这样就可以通过建立的变量来调用内部函数的变量,并对内部函数的变量进行修改。</p>
<ul>
<li>如一开始的函数，如果使用注释的代码所使用的方法，并不会改变this本身的指向，本身还是指向全局，但是通过变量的this则是指向函数自身，这样就可以依据业务选择使用全局this还是局部的this</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Num)</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(Obj.ObjNum)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="构造函数调用">构造函数调用</h3>
<p>使用构造函数是，new会创建一个新的对象，新的对象会继承构造函数的属性和方法。<br>
不仅创建一个连接到该函数的<code>prototype</code>成员的新对象，同时this会被绑定到这个创建的新对象。</p>
<ul>
<li>打印<code>MyFn</code>,可以看出创建了一个包含了<code>value</code>的新对象，同时创建的<code>get_value</code>也被绑定在这个新的对象上</li>
<li>打印<code>Fn</code>，可以看出new的对象不会对原函数有任何的影响</li>
<li>打印<code>MyFn.value</code>，因为this绑定到了创建的<code>MyFn</code>对象上，所以可以成功获取数据</li>
<li>打印<code>Fn.value</code>，因为this绑定到了创建的MyFn对象上，没有对<code>Fn</code>这个本身的函数有影响，所以<code>Fn</code>的原型链上不包含<code>value</code>属性，所以会返回<code>undefined</code></li>
<li>打印<code>MyFn.get_value()</code>，因为<code>get_value()</code>方法通过this绑定到了<code>MyFn</code>上，所以在函数调用函数，可以成功return之前绑定的<code>this.value</code>的值</li>
<li>打印<code>Fn.get_value()</code>，因为Fn上没有<code>get_value()</code>函数，所以浏览器会报错</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数</span></span><br><span class="line"><span class="keyword">const</span> Fn = <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.value = string</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 创建一个原型链</span></span><br><span class="line">Fn.prototype.get_value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> MyFn = <span class="keyword">new</span> Fn(<span class="string">'这是构造函数new的值'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(MyFn)</span><br><span class="line"><span class="comment">// [object Object] {</span></span><br><span class="line"><span class="comment">//   get_value: function () {</span></span><br><span class="line"><span class="comment">//     return this.value</span></span><br><span class="line"><span class="comment">//   },</span></span><br><span class="line"><span class="comment">//   value: "这是构造函数new的值"</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn)</span><br><span class="line"><span class="comment">// function (string) {</span></span><br><span class="line"><span class="comment">//   this.value = string</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"><span class="built_in">console</span>.log(MyFn.value)</span><br><span class="line"><span class="comment">// "这是构造函数new的值"</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.value)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(MyFn.get_value())</span><br><span class="line"><span class="comment">// "这是构造函数new的值"</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.get_value())</span><br><span class="line"><span class="comment">// TypeError: Fn.get_value is not a function</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="apply和call调用">apply和call调用</h3>
<p><code>apply</code>和<code>call</code>的作用一样，区别在于参数的传递<br>
<code>apply</code>和<code>call</code>的第一个参数都是函数体内this的指向<br>
<code>qpply</code>的第二个参数是一个集合对象<br>
<code>call</code>的第二个参数是是依次传入的参数</p>
<ul>
<li>改变this指向</li>
<li>方法借用</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ObjOne = {</span><br><span class="line">  Num: <span class="number">1</span>,</span><br><span class="line">  Str: <span class="string">'对象1'</span>,</span><br><span class="line">  ObjOneFn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.Num)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.Str)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 对象2</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 对象3</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> ObjTwo = {</span><br><span class="line">  Num: <span class="number">2</span>,</span><br><span class="line">  Str: <span class="string">'对象2'</span>,</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> ObjThree = {</span><br><span class="line">  Num: <span class="number">3</span>,</span><br><span class="line">  Str: <span class="string">'对象3'</span></span><br><span class="line">}</span><br><span class="line">ObjOne.ObjOneFn.apply(ObjTwo)</span><br><span class="line">ObjOne.ObjOneFn.call(ObjThree)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="箭头函数调用">箭头函数调用</h3>
<p>参考使用了内部函数的对象函数调用this，可以知道this的指向是全局，所以在这个函数中，打印的内容是<code>undefined</code>。</p>
<ul>
<li>使用原本的函数</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Obj = {</span><br><span class="line">  ObjNum: <span class="number">1</span>,</span><br><span class="line">  ObjFn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    ObjLog = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.ObjNum)</span><br><span class="line">      <span class="comment">// undefined</span></span><br><span class="line">    }</span><br><span class="line">    ObjLog()</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">Obj.ObjFn()</span><br></pre></td></tr></tbody></table></figure>
<p>但是除了通过在函数体内定义一个变量，指定this，以实现内部函数调用函数体内变量的方法，还可以通过箭头函数直接改变this指向。<br>
因为箭头函数自身没有指定this的指向，所以会向上层作用域查找，<code>ObjFn</code>的this指向<code>Obj</code>，所以箭头函数的this也指向<code>Obj</code>，即可输出函数体内的数据。</p>
<ul>
<li>使用箭头函数</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Obj = {</span><br><span class="line">  ObjNum: <span class="number">1</span>,</span><br><span class="line">  ObjFn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    ObjLog = <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.ObjNum)</span><br><span class="line">      <span class="comment">// 1</span></span><br><span class="line">    }</span><br><span class="line">    ObjLog()</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">Obj.ObjFn()</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JS面试</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-数组去重</title>
    <url>/2020/JavaScript-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<p>在JavaScript操作中，经常有关于Array的操作，常见的操作有增删改查，排序去重等等，但是数组的去重经常要用到自己手写的代码，网上查询关于JavaScript的数组去重操作都有很多方法，但是关于数组的操作不是copy代码就可以做到高枕无忧的。</p>
<a id="more"></a>
<p>不同的方法会有不同的耗时，对于性能的影响也各不相同，在数据量小的时候尚不明显，但是在大数据的情况下，如果数据量很是庞大，那么耗时是很明显的，所以这么多关于数组去重的方法，到底那种方法更好呢。<br>
为了知道数组去重对于时间的消耗，手动进行了测试。</p>
<table>
<thead>
<tr>
<th>去重方法</th>
<th>10000</th>
<th>100000</th>
<th>1000000</th>
<th>10000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>利用ES6 Set去重</td>
<td>5ms</td>
<td>15ms</td>
<td>252ms</td>
<td>4148ms</td>
</tr>
<tr>
<td>for循环，splice去重</td>
<td>273ms</td>
<td>27422ms</td>
<td>未测试</td>
<td>未测试</td>
</tr>
<tr>
<td>利用indexOf去重</td>
<td>138ms</td>
<td>13487ms</td>
<td>未测试</td>
<td>未测试</td>
</tr>
<tr>
<td>利用sort()</td>
<td>5ms</td>
<td>47ms</td>
<td>375ms</td>
<td>4018ms</td>
</tr>
<tr>
<td>利用includes</td>
<td>150ms</td>
<td>15134ms</td>
<td>未测试</td>
<td>未测试</td>
</tr>
<tr>
<td>利用Map结构数据</td>
<td>8ms</td>
<td>36ms</td>
<td>471ms</td>
<td>5873ms</td>
</tr>
</tbody>
</table>
<ul>
<li>创建数组</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ArrStart = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>), (item, index) =&gt; {</span><br><span class="line">  arr.push(index)</span><br><span class="line">  arr.push(index + index) sasdsa</span><br><span class="line">})</span><br><span class="line"><span class="keyword">const</span> ArrEnd = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'创建数据耗时：'</span> + (ArrEnd - ArrStart) + <span class="string">'ms'</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>去重方法</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deduplication</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="comment">// 去重的具体方法</span></span><br><span class="line">}</span><br><span class="line">Deduplication(arr)</span><br><span class="line"><span class="keyword">const</span> End = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'去重耗时：'</span> + (End - Start) + <span class="string">'ms'</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>排序方法</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> StartSort = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">const</span> sortResult = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">})</span><br><span class="line"><span class="keyword">const</span> EndSort = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'排序耗时：'</span> + (EndSort - StartSort) + <span class="string">'ms'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="利用ES6-Set去重-ES6常见">利用ES6 Set去重(ES6常见)</h4>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deduplication</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="利用for嵌套for，然后splice去重-ES5常见">利用for嵌套for，然后splice去重(ES5常见)</h4>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deduplication</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++){</span><br><span class="line">      <span class="keyword">if</span>(arr[i]==arr[j]){         <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">        arr.splice(j,<span class="number">1</span>);</span><br><span class="line">        j--;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="利用IndexOf">利用IndexOf</h4>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deduplication</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">var</span> array = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (array.indexOf(arr[i]) === <span class="number">-1</span>) {</span><br><span class="line">      array.push(arr[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="利用sort">利用sort()</h4>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deduplication</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  arr = arr.sort()</span><br><span class="line">  <span class="keyword">var</span> arrry = [arr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== arr[i - <span class="number">1</span>]) {</span><br><span class="line">      arrry.push(arr[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> arrry;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="利用includes">利用includes</h4>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deduplication</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">var</span> array = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (!array.includes(arr[i])) {<span class="comment">//includes 检测数组是否有某个值</span></span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="利用Map结构数据">利用Map结构数据</h4>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deduplication</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">// 数组用于返回结果</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (map.has(arr[i])) {  <span class="comment">// 如果有该key值</span></span><br><span class="line">      map.set(arr[i], <span class="literal">true</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      map.set(arr[i], <span class="literal">false</span>);   <span class="comment">// 如果没有该key值</span></span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>经过一轮测试</p>
<ul>
<li>利用ES6 Set去重</li>
<li>利用sort()</li>
<li>利用Map结构数据<br>
均可在百万数据量的时候实现快速去重，千万级数据也能较快去重</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-Array-几个数组函数的比较</title>
    <url>/2020/JavaScript-Array-Compare/</url>
    <content><![CDATA[<p>因为平时forEach用的多，知其然不知其所以然。所以对几个数组函数，Array.map()，Array.forEach()，Array.reduce()的用法和使用场景做出了简单的分析</p>
<a id="more"></a>
<p>官方文档有过介绍，forEach和map都是遍历数据之后可以进行操作<br>
forEach可以改变原数组，map不能改变原数组，map是通过生成新数组来实现操作的<br>
但是实际测试不然，forEach是通过数组引用改变原数组，实际map也是可以这样做到的</p>
<h4 id="Array-prototype-forEach">Array.prototype.forEach()</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">MDN官方文档</a><br>
遍历数组的每一项，以执行给定函数，不可以返回新数组</p>
<ul>
<li>在操作中写函数，但是不涉及对数组的操作，不会影响原数组<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [4, 5, 8]</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>在操作中写函数，涉及对数组引用方式的操作，会改变原数组<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr[index] = item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 8, 10, 16 ]</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>尝试把forEach的遍历处理的数据写入新数组，返回undefined<br>
由此得知forEach不能创建数组<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="Array-prototype-map">Array.prototype.map()</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">MDN官方文档</a></p>
<ul>
<li>在操作中写函数，但是不涉及对数组的操作，不会影响原数组<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 4, 5, 8 ]</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>在操作中写函数，涉及对数组引用的操作，会改变原数组<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr[index] = item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 8, 10, 16 ]</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>尝试把map的遍历处理的数据写入新数组，返回对应数据<br>
由此得知map可以创建新的栈区<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">// [ 8, 10, 16 ]</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="Array-prototype-reduce">Array.prototype.reduce()</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" target="_blank" rel="noopener">MDN官方文档</a><br>
如果对数据处理是需要循环处理，并且下一次的处理需要和上一次处理的数据相关联，而且处理流程的函数方法都一样，那么可以通过reduce，省略很多步骤</p>
<ul>
<li>累加<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">23</span>]</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"><span class="keyword">const</span> test1 = arr.reduce(reducer)</span><br><span class="line"><span class="built_in">console</span>.log(test1)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="分析总结">分析总结</h4>
<ul>
<li><code>map</code>和<code>forEach</code><br>
虽然文档说<code>map</code>和<code>forEach</code>在对原数组操作模式上不一样<br>
测试之后其实也是有共通之处的<br>
所不同的地方在于，<code>map</code>可以返回一个新数组，<code>forEach</code>不可以<br>
所以结合官方和众人的经验总结，对于<code>map</code>和<code>forEach</code>在不同场景下选取不同的使用<br>
如果需要涉及对数据有改动的相关操作使用<code>map</code><br>
如果是对数据无改动，对数据查询，写入数据库等操作，使用<code>forEach</code></li>
<li>与<code>reduce</code>的使用关系<br>
当复杂的函数可以使用map处理<br>
简单的函数处理，重复工作的累加累减这种可以使用reduce<br>
使用reduce可以减少代码量</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
